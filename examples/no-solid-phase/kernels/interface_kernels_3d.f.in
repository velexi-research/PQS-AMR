c***********************************************************************
c
c interface_kernels_3d.f
c
c Subroutines to initialize fluid-fluid interface for example
c application with no solid phase in three spatial dimensions.
c
c***********************************************************************

c***********************************************************************
c
c Initalize level set function, phi, for fluid-fluid interface to be
c a sphere.
c
c Parameters
c ----------
c phi: [output] level set function that defines fluid-fluid interface
c
c x_lower: array containing coordinates of lower corner of grid
c    (excluding ghost cells)
c
c dx: array containing grid spacing in each coordinate direction
c
c center: array containing coordinates of center of circle
c
c radius: radius of circle
c
c *_gb_lo: lower corner of index range for ghostbox
c
c *_gb_hi: upper corner of index range for ghostbox
c
c fb_lo: lower corner of index range for fillbox
c
c fb_hi: upper corner of index range for fillbox
c
c***********************************************************************
      subroutine init_sphere(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  fb_lo, fb_hi,
     &  x_lower,
     &  dx,
     &  center,
     &  radius)
c***********************************************************************
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      real*8 dx(1:3)
      real*8 x_lower(1:3)

      real*8 center(1:3)
      real*8 radius

      real*8 x, y, z
      integer i, j, k

c     loop over grid
      do k=fb_lo(3), fb_hi(3)
        do j=fb_lo(2), fb_hi(2)
          do i=fb_lo(1), fb_hi(1)

            x = x_lower(1) + dx(1)*(i-fb_lo(1)+0.5) - center(1)
            y = x_lower(2) + dx(2)*(j-fb_lo(2)+0.5) - center(2)
            z = x_lower(3) + dx(3)*(k-fb_lo(3)+0.5) - center(3)

            phi(i,j,k) = sqrt(x**2 + y**2 + z**2) - radius

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c***********************************************************************

c***********************************************************************
c
c Initalize level set function, phi, for fluid-fluid interface to be
c a bumpy sphere.
c
c Parameters
c ----------
c phi: [output] level set function that defines fluid-fluid interface
c
c x_lower: array containing coordinates of lower corner of grid
c    (excluding ghost cells)
c
c dx: array containing grid spacing in each coordinate direction
c
c center: array containing coordinates of center of circle
c
c radius: radius of circle
c
c *_gb_lo: lower corner of index range for ghostbox
c
c *_gb_hi: upper corner of index range for ghostbox
c
c fb_lo: lower corner of index range for fillbox
c
c fb_hi: upper corner of index range for fillbox
c
c***********************************************************************
      subroutine init_bumpy_sphere(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  fb_lo, fb_hi,
     &  x_lower,
     &  dx,
     &  center,
     &  radius)
c***********************************************************************
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      real*8 dx(1:3)
      real*8 x_lower(1:3)

      real*8 center(1:3)
      real*8 radius
      real*8 theta, azimuth

      real*8 x, y, z
      real*8 rho
      integer i, j, k

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

c     loop over grid
      do k=fb_lo(3), fb_hi(3)
        do j=fb_lo(2), fb_hi(2)
          do i=fb_lo(1), fb_hi(1)

            x = x_lower(1) + dx(1)*(i-fb_lo(1)+0.5) - center(1)
            y = x_lower(2) + dx(2)*(j-fb_lo(2)+0.5) - center(2)
            z = x_lower(3) + dx(3)*(k-fb_lo(3)+0.5) - center(3)

            phi(i,j,k) = sqrt(x**2 + y**2 + z**2) - radius

            theta = atan2(y,x)
            rho = sqrt(x**2 + y**2 + z**2)
            if (rho .gt. zero_tol) then
                azimuth = acos(z / rho)
            else
                azimuth = 0.0
            endif

            phi(i,j,k) = rho
     &          - radius*(1 + 0.25 * sin(4*azimuth) * cos(5*theta))

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c***********************************************************************
