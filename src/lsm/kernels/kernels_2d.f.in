c***********************************************************************
c
c kernels_2d.f
c
c F77 routines for Level Set Method computations in two space dimensions
c
c***********************************************************************

c***********************************************************************
c
c Compute area of region where signed distance function is less than 0.
c
c Parameters
c ----------
c phi: signed distance function
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: width of numerical smoothing to use for Heaviside function
c
c *_gb_lo: lower corner of index range for ghostbox
c
c *_gb_hi: upper corner of index range for ghostbox
c
c ib_lo: lower corner of index range for interior box
c
c ib_hi: upper corner of index range for interior box
c
c Return value
c ------------
c area of region where phi < 0
c
c***********************************************************************
      @REAL@ function pqsLsm2dAreaPhiLessThanZero(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  ib_lo, ib_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2))

      integer ib_lo(1:2), ib_hi(1:2)
      real*8 dx(1:2)
      real*8 eps

      integer i, j
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 one_minus_H
      real*8 dA
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)

      real*8 area

c     compute dA
      dA = dx(1) * dx(2)

c     initialize area to zero
      area = 0.0d0

c     loop over interior cells {
      do j=ib_lo(2),ib_hi(2)
        do i=ib_lo(1),ib_hi(1)

          phi_cur = phi(i,j)
          phi_cur_over_eps = phi_cur/eps

          if (phi_cur .lt. -eps) then

            area = area + dA

          elseif (phi_cur .lt.  eps) then

            one_minus_H = 0.5d0*( 1 - phi_cur_over_eps
     &                              - one_over_pi
     &                               *sin(pi*phi_cur_over_eps))

            area = area + one_minus_H*dA

          endif

        enddo
      enddo
c     } end loop over interior cells

c     set result
      pqsLsm2dAreaPhiLessThanZero = area

      return
      end
c } end function

c***********************************************************************
c
c Compute area of region where signed distance function is greater
c than 0.
c
c Parameters
c ----------
c phi: signed distance function
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: width of numerical smoothing to use for Heaviside function
c
c *_gb_lo: lower corner of index range for ghostbox
c
c *_gb_hi: upper corner of index range for ghostbox
c
c ib_lo: lower corner of index range for interior box
c
c ib_hi: upper corner of index range for interior box
c
c Return value
c ------------
c area of region where phi > 0
c
c***********************************************************************
      @REAL@ function pqsLsm2dAreaPhiGreaterThanZero(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  ib_lo, ib_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2))

      integer ib_lo(1:2), ib_hi(1:2)
      real*8 dx(1:2)
      real*8 eps

      integer i, j
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 H
      real*8 dA
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)

      real*8 area

c     compute dA
      dA = dx(1) * dx(2)

c     initialize area to zero
      area = 0.0d0

c     loop over interior cells {
      do j=ib_lo(2),ib_hi(2)
        do i=ib_lo(1),ib_hi(1)

          phi_cur = phi(i,j)
          phi_cur_over_eps = phi_cur/eps

          if (phi_cur .gt. eps) then

            area = area + dA

          elseif (phi_cur .gt.  -eps) then

            H = 0.5d0*( 1 + phi_cur_over_eps
     &                    + one_over_pi*sin(pi*phi_cur_over_eps))

            area = area + H*dA

          endif

        enddo
      enddo
c     } end loop over interior cells

c     set result
      pqsLsm2dAreaPhiGreaterThanZero = area

      return
      end
c } end function
