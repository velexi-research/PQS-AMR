c***********************************************************************
c
c time_integration_3d.f
c
c Time integration subroutines for problems in three space dimensions
c
c***********************************************************************

c***********************************************************************
c The TVD Runge-Kutta methods implemented in these subroutines are
c discussed in "Level Set Methods and Dynamic Implicit Surfaces" by
c Osher & Fedkiw (2003).
c***********************************************************************

c***********************************************************************
c
c Advance the solution 'u' through a single first-order Runge-Kutta
c (i.e, forward Euler) step.
c
c Parameters
c ----------
c u_next: [output] u(t + dt)
c
c u_currentrent: u(t)
c
c rhs: right-hand side of time evolution equation
c
c dt: step size
c
c *_gb: index range for ghostbox
c
c *_fb: index range for fillbox
c
c Notes
c -----
c * This is also the first step of all of the TVD Runge-Kutta schemes
c   implemented in this library.
c
c***********************************************************************
      subroutine pqsMath3dRK1Step(
     &  u_next,
     &  u_next_gb_lo, u_next_gb_hi,
     &  u_current,
     &  u_current_gb_lo, u_current_gb_hi,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  fb_lo, fb_hi,
     &  dt)
c***********************************************************************
c { begin subroutine
      implicit none

      integer u_next_gb_lo(1:3), u_next_gb_hi(1:3)
      @REAL@ u_next(u_next_gb_lo(1):u_next_gb_hi(1),
     &              u_next_gb_lo(2):u_next_gb_hi(2),
     &              u_next_gb_lo(3):u_next_gb_hi(3))

      integer u_current_gb_lo(1:3), u_current_gb_hi(1:3)
      @REAL@ u_current(u_current_gb_lo(1):u_current_gb_hi(1),
     &                 u_current_gb_lo(2):u_current_gb_hi(2),
     &                 u_current_gb_lo(3):u_current_gb_hi(3))

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      integer i, j, k
      real*8 dt

c     { begin loop over grid
      do k=fb_lo(3),fb_hi(3)
        do j=fb_lo(2),fb_hi(2)
          do i=fb_lo(1),fb_hi(1)

            u_next(i,j,k) = u_current(i,j,k) + dt*rhs(i,j,k)

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Advance the solution 'u' by through first stage of a second-order
c TVD Runge-Kutta step.
c
c Parameters
c ----------
c u_stage1: [output] u_approx(t + dt)
c
c u_cur: u(t)
c
c rhs: right-hand side of time evolution equation
c
c dt: step size
c
c *_gb: index range for ghostbox
c
c *_fb: index range for fillbox
c
c NOTES:
c  - the first stage of TVD RK2 is identical to a single RK1 step
c
c***********************************************************************
      subroutine pqsMath3dTVDRK2Stage1(
     &  u_stage1,
     &  u_stage1_gb_lo, u_stage1_gb_hi,
     &  u_current,
     &  u_current_gb_lo, u_current_gb_hi,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  fb_lo, fb_hi,
     &  dt)
c***********************************************************************
c { begin subroutine
      implicit none

      integer u_stage1_gb_lo(1:3), u_stage1_gb_hi(1:3)
      @REAL@ u_stage1(u_stage1_gb_lo(1):u_stage1_gb_hi(1),
     &                u_stage1_gb_lo(2):u_stage1_gb_hi(2),
     &                u_stage1_gb_lo(3):u_stage1_gb_hi(3))

      integer u_current_gb_lo(1:3), u_current_gb_hi(1:3)
      @REAL@ u_current(u_current_gb_lo(1):u_current_gb_hi(1),
     &                 u_current_gb_lo(2):u_current_gb_hi(2),
     &                 u_current_gb_lo(3):u_current_gb_hi(3))

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      real*8 dt

c     use pqsMath3dRK1Step() to compute first stage
      call pqsMath3dRK1Step(u_stage1,
     &                      u_stage1_gb_lo, u_stage1_gb_hi,
     &                      u_current,
     &                      u_current_gb_lo, u_current_gb_hi,
     &                      rhs,
     &                      rhs_gb_lo, rhs_gb_hi,
     &                      fb_lo, fb_hi,
     &                      dt)

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Advance the solution 'u' by through second stage of a second-order
c TVD Runge-Kutta step.
c
c Parameters
c ----------
c u_next: [output] u(t + dt)
c
c u_stage1: u_approx(t + dt)
c
c u_cur: u(t)
c
c rhs: right-hand side of time evolution equation
c
c dt: step size
c
c *_gb: index range for ghostbox
c
c *_fb: index range for fillbox
c
c***********************************************************************
      subroutine pqsMath3dTVDRK2Stage2(
     &  u_next,
     &  u_next_gb_lo, u_next_gb_hi,
     &  u_stage1,
     &  u_stage1_gb_lo, u_stage1_gb_hi,
     &  u_current,
     &  u_current_gb_lo, u_current_gb_hi,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  fb_lo, fb_hi,
     &  dt)
c***********************************************************************
c { begin subroutine
      implicit none

      integer u_next_gb_lo(1:3), u_next_gb_hi(1:3)
      @REAL@ u_next(u_next_gb_lo(1):u_next_gb_hi(1),
     &              u_next_gb_lo(2):u_next_gb_hi(2),
     &              u_next_gb_lo(3):u_next_gb_hi(3))

      integer u_stage1_gb_lo(1:3), u_stage1_gb_hi(1:3)
      @REAL@ u_stage1(u_stage1_gb_lo(1):u_stage1_gb_hi(1),
     &                u_stage1_gb_lo(2):u_stage1_gb_hi(2),
     &                u_stage1_gb_lo(3):u_stage1_gb_hi(3))

      integer u_current_gb_lo(1:3), u_current_gb_hi(1:3)
      @REAL@ u_current(u_current_gb_lo(1):u_current_gb_hi(1),
     &                 u_current_gb_lo(2):u_current_gb_hi(2),
     &                 u_current_gb_lo(3):u_current_gb_hi(3))

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      integer i, j, k
      real*8 dt

c     { begin loop over grid
      do k=fb_lo(3),fb_hi(3)
        do j=fb_lo(2),fb_hi(2)
          do i=fb_lo(1),fb_hi(1)

            u_next(i,j,k) = 0.5d0*( u_current(i,j,k)
     &                            + u_stage1(i,j,k) + dt*rhs(i,j,k) )
          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Advance the solution 'u' by through first stage of a third-order
c TVD Runge-Kutta step.
c
c Parameters
c ----------
c u_stage1: [output] u_approx(t + dt)
c
c u_cur: u(t)
c
c rhs: right-hand side of time evolution equation
c
c dt: step size
c
c *_gb: index range for ghostbox
c
c *_fb: index range for fillbox
c
c NOTES:
c  - the first stage of TVD RK3 is identical to a single RK1 step
c
c***********************************************************************
      subroutine pqsMath3dTVDRK3Stage1(
     &  u_stage1,
     &  u_stage1_gb_lo, u_stage1_gb_hi,
     &  u_current,
     &  u_current_gb_lo, u_current_gb_hi,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  fb_lo, fb_hi,
     &  dt)
c***********************************************************************
c { begin subroutine
      implicit none

      integer u_stage1_gb_lo(1:3), u_stage1_gb_hi(1:3)
      @REAL@ u_stage1(u_stage1_gb_lo(1):u_stage1_gb_hi(1),
     &                u_stage1_gb_lo(2):u_stage1_gb_hi(2),
     &                u_stage1_gb_lo(3):u_stage1_gb_hi(3))

      integer u_current_gb_lo(1:3), u_current_gb_hi(1:3)
      @REAL@ u_current(u_current_gb_lo(1):u_current_gb_hi(1),
     &                 u_current_gb_lo(2):u_current_gb_hi(2),
     &                 u_current_gb_lo(3):u_current_gb_hi(3))

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      real*8 dt

c     use pqsMath3dRK1Step() to compute first stage
      call pqsMath3dRK1Step(u_stage1,
     &                      u_stage1_gb_lo, u_stage1_gb_hi,
     &                      u_current,
     &                      u_current_gb_lo, u_current_gb_hi,
     &                      rhs,
     &                      rhs_gb_lo, rhs_gb_hi,
     &                      fb_lo, fb_hi,
     &                      dt)

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Advance the solution 'u' by through second stage of a third-order
c TVD Runge-Kutta step.
c
c Parameters
c ----------
c u_stage2: [output] u_approx(t + dt/2)
c
c u_stage1: u_approx(t + dt)
c
c u_cur: u(t)
c
c rhs: right-hand side of time evolution equation
c
c dt: step size
c
c *_gb: index range for ghostbox
c
c *_fb: index range for fillbox
c
c***********************************************************************
      subroutine pqsMath3dTVDRK3Stage2(
     &  u_stage2,
     &  u_stage2_gb_lo, u_stage2_gb_hi,
     &  u_stage1,
     &  u_stage1_gb_lo, u_stage1_gb_hi,
     &  u_current,
     &  u_current_gb_lo, u_current_gb_hi,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  fb_lo, fb_hi,
     &  dt)
c***********************************************************************
c { begin subroutine
      implicit none

      integer u_stage2_gb_lo(1:3), u_stage2_gb_hi(1:3)
      @REAL@ u_stage2(u_stage2_gb_lo(1):u_stage2_gb_hi(1),
     &                u_stage2_gb_lo(2):u_stage2_gb_hi(2),
     &                u_stage2_gb_lo(3):u_stage2_gb_hi(3))

      integer u_stage1_gb_lo(1:3), u_stage1_gb_hi(1:3)
      @REAL@ u_stage1(u_stage1_gb_lo(1):u_stage1_gb_hi(1),
     &                u_stage1_gb_lo(2):u_stage1_gb_hi(2),
     &                u_stage1_gb_lo(3):u_stage1_gb_hi(3))

      integer u_current_gb_lo(1:3), u_current_gb_hi(1:3)
      @REAL@ u_current(u_current_gb_lo(1):u_current_gb_hi(1),
     &                 u_current_gb_lo(2):u_current_gb_hi(2),
     &                 u_current_gb_lo(3):u_current_gb_hi(3))

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      integer i, j, k
      real*8 dt

c     { begin loop over grid
      do k=fb_lo(3),fb_hi(3)
        do j=fb_lo(2),fb_hi(2)
          do i=fb_lo(1),fb_hi(1)

            u_stage2(i,j,k) = 0.75d0*u_current(i,j,k)
     &                      + 0.25d0*(u_stage1(i,j,k) + dt*rhs(i,j,k))

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Advance the solution 'u' by through third stage of a third-order
c TVD Runge-Kutta step.
c
c Parameters
c ----------
c u_next: [output] u(t + dt)
c
c u_stage2: u_approx(t + dt/2)
c
c u_cur: u(t)
c
c rhs: right-hand side of time evolution equation
c
c dt: step size
c
c *_gb: index range for ghostbox
c
c *_fb: index range for fillbox
c
c***********************************************************************
      subroutine pqsMath3dTVDRK3Stage3(
     &  u_next,
     &  u_next_gb_lo, u_next_gb_hi,
     &  u_stage2,
     &  u_stage2_gb_lo, u_stage2_gb_hi,
     &  u_current,
     &  u_current_gb_lo, u_current_gb_hi,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  fb_lo, fb_hi,
     &  dt)
c***********************************************************************
c { begin subroutine
      implicit none

      integer u_next_gb_lo(1:3), u_next_gb_hi(1:3)
      @REAL@ u_next(u_next_gb_lo(1):u_next_gb_hi(1),
     &              u_next_gb_lo(2):u_next_gb_hi(2),
     &              u_next_gb_lo(3):u_next_gb_hi(3))

      integer u_stage2_gb_lo(1:3), u_stage2_gb_hi(1:3)
      @REAL@ u_stage2(u_stage2_gb_lo(1):u_stage2_gb_hi(1),
     &                u_stage2_gb_lo(2):u_stage2_gb_hi(2),
     &                u_stage2_gb_lo(3):u_stage2_gb_hi(3))

      integer u_current_gb_lo(1:3), u_current_gb_hi(1:3)
      @REAL@ u_current(u_current_gb_lo(1):u_current_gb_hi(1),
     &                 u_current_gb_lo(2):u_current_gb_hi(2),
     &                 u_current_gb_lo(3):u_current_gb_hi(3))

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer fb_lo(1:3), fb_hi(1:3)

      integer i, j, k
      real*8 dt
      @REAL@ one_third, two_thirds
      parameter (one_third = 1.d0/3.d0)
      parameter (two_thirds = 2.d0/3.d0)

c     { begin loop over grid
      do k=fb_lo(3),fb_hi(3)
        do j=fb_lo(2),fb_hi(2)
          do i=fb_lo(1),fb_hi(1)

            u_next(i,j,k) = one_third*u_current(i,j,k)
     &                    + two_thirds*( u_stage2(i,j,k)
     &                                 + dt*rhs(i,j,k) )

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************
