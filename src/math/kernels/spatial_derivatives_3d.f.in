c***********************************************************************
c
c spatial_derivatives_3d.f
c
c Spatial derivative functions/subroutines for mathematical functions
c of three space variables
c
c***********************************************************************

c***********************************************************************
c The ENO/WENO methods implemented in these subroutines are discussed
c in "Level Set Methods and Dynamic Implicit Surfaces" by Osher &
c Fedkiw (2003).
c***********************************************************************

c***********************************************************************
c
c Compute the forward (plus) and backward (minus) ENO1 difference
c approximations for the gradient of phi. For instance, the ENO1
c difference approximation in the x-direction are given by
c
c   phi_x_plus = ( phi(i+1,j,k) - phi(i,j,k) ) / dx(1)
c
c   phi_x_minus = ( phi(i,j,k) - phi(i-1,j,k) ) / dx(1)
c
c Parameters
c ----------
c grad_phi_*_plus: [output] components of grad(phi) in plus direction
c
c grad_phi_*_minus: [output] components of grad(phi) in minus direction
c
c phi: function to compute gradient of
c
c dx: array containing grid spacing in each coordinate direction
c
c idx: array containing index of grid point to compute gradient at
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqsMath3dComputeGradENO1(
     &  grad_phi_x_plus, grad_phi_x_minus,
     &  grad_phi_y_plus, grad_phi_y_minus,
     &  grad_phi_z_plus, grad_phi_z_minus,
     &  phi, phi_gb_lo, phi_gb_hi,
     &  dx,
     &  idx)
c***********************************************************************
c { begin subroutine
      implicit none

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_z_plus, grad_phi_z_minus

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      real*8 dx(1:3)
      integer idx(1:3)

      integer i, j, k

c     Preparations
      i = idx(1)
      j = idx(2)
      k = idx(3)

c     Compute gradients
      grad_phi_x_plus = (phi(i+1,j,k) - phi(i,j,k)) / dx(1)
      grad_phi_x_minus = (phi(i,j,k) - phi(i-1,j,k)) / dx(1)

      grad_phi_y_plus = (phi(i,j+1,k) - phi(i,j,k)) / dx(2)
      grad_phi_y_minus = (phi(i,j,k) - phi(i,j-1,k)) / dx(2)

      grad_phi_z_plus = (phi(i,j,k+1) - phi(i,j,k)) / dx(3)
      grad_phi_z_minus = (phi(i,j,k) - phi(i,j,k-1)) / dx(3)

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute the forward (plus) and backward (minus) WENO5 difference
c approximations for the gradient of phi.
c
c Parameters
c ----------
c grad_phi_*_plus: [output] components of grad(phi) in plus direction
c
c grad_phi_*_minus: [output] components of grad(phi) in minus direction
c
c phi: function to compute gradient of
c
c dx: array containing grid spacing in each coordinate direction
c
c idx: array containing index of grid point to compute gradient at
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqsMath3dComputeGradWENO5(
     &  grad_phi_x_plus, grad_phi_x_minus,
     &  grad_phi_y_plus, grad_phi_y_minus,
     &  grad_phi_z_plus, grad_phi_z_minus,
     &  phi, phi_gb_lo, phi_gb_hi,
     &  dx,
     &  idx)
c***********************************************************************
c { begin subroutine
      implicit none

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_z_plus, grad_phi_z_minus

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      real*8 dx(1:3)
      integer idx(1:3)

c     variables for WENO calculation
      @REAL@ v1, v2, v3, v4, v5, v_swap
      @REAL@ S1, S2, S3
      @REAL@ a1, a2, a3, inv_sum_a
      @REAL@ grad_phi_1, grad_phi_2, grad_phi_3
      @REAL@ tiny_nonzero_number
      parameter (tiny_nonzero_number=@TINY_NONZERO_NUMBER@)
      @REAL@ eps
      @REAL@ one_third, seven_sixths, eleven_sixths
      @REAL@ one_sixth, five_sixths
      @REAL@ thirteen_twelfths, one_fourth
      parameter (one_third=1.d0/3.d0)
      parameter (seven_sixths=7.d0/6.d0)
      parameter (eleven_sixths=11.d0/6.d0)
      parameter (one_sixth=1.d0/6.d0)
      parameter (five_sixths=5.d0/6.d0)
      parameter (thirteen_twelfths=13.d0/12.d0)
      parameter (one_fourth=0.25d0)

      integer i, j, k

c     --- Preparations

      i = idx(1)
      j = idx(2)
      k = idx(3)

c     --- Compute grad_phi_x

c     ------ Compute grad_phi_x_minus

c     Compute first-order finite differences for WENO5 calculation
      v1 = (phi(i-2,j,k) - phi(i-3,j,k)) / dx(1)
      v2 = (phi(i-1,j,k) - phi(i-2,j,k)) / dx(1)
      v3 = (phi(i,j,k) - phi(i-1,j,k)) / dx(1)
      v4 = (phi(i+1,j,k) - phi(i,j,k)) / dx(1)
      v5 = (phi(i+2,j,k) - phi(i+1,j,k)) / dx(1)

c     Compute eps for current grid point
      eps = 1e-6*max(v1*v1, v2*v2, v3*v3, v4*v4, v5*v5)
     &    + tiny_nonzero_number

c     Compute grad_phi_1, grad_phi_2, grad_phi_3
      grad_phi_1 = one_third*v1 - seven_sixths*v2 + eleven_sixths*v3
      grad_phi_2 = -one_sixth*v2 + five_sixths*v3 + one_third*v4
      grad_phi_3 = one_third*v3 + five_sixths*v4 - one_sixth*v5

c     Compute WENO5 smoothness measures
      S1 = thirteen_twelfths*(v1-2.d0*v2+v3)**2
     &   + one_fourth*(v1-4.d0*v2+3.d0*v3)**2
      S2 = thirteen_twelfths*(v2-2.d0*v3+v4)**2
     &   + one_fourth*(v2-v4)**2
      S3 = thirteen_twelfths*(v3-2.d0*v4+v5)**2
     &   + one_fourth*(3.d0*v3-4.d0*v4+v5)**2

c     Compute normalized weights
      a1 = 0.1d0/(S1+eps)**2
      a2 = 0.6d0/(S2+eps)**2
      a3 = 0.3d0/(S3+eps)**2
      inv_sum_a = 1.0d0 / (a1 + a2 + a3)
      a1 = a1*inv_sum_a
      a2 = a2*inv_sum_a
      a3 = a3*inv_sum_a

c     Compute grad_phi_x_minus
      grad_phi_x_minus =
     &    a1*grad_phi_1 + a2*grad_phi_2 + a3*grad_phi_3

c     ------ Compute grad_phi_x_plus

c     Compute first-order finite differences for WENO5 calculation
c
c     Note: we can reuse values used to compute grad_phi_y_minus

      v1 = (phi(i+3,j,k) - phi(i+2,j,k)) / dx(1)

      v_swap = v2
      v2 = v5
      v5 = v_swap

      v_swap = v3
      v3 = v4
      v4 = v_swap

c     Compute eps for current grid point
      eps = 1e-6*max(v1*v1, v2*v2, v3*v3, v4*v4, v5*v5)
     &    + tiny_nonzero_number

c     Compute grad_phi_1, grad_phi_2, grad_phi_3
      grad_phi_1 = one_third*v1 - seven_sixths*v2 + eleven_sixths*v3
      grad_phi_2 = -one_sixth*v2 + five_sixths*v3 + one_third*v4
      grad_phi_3 = one_third*v3 + five_sixths*v4 - one_sixth*v5

c     Compute WENO5 smoothness measures
      S1 = thirteen_twelfths*(v1-2.d0*v2+v3)**2
     &   + one_fourth*(v1-4.d0*v2+3.d0*v3)**2
      S2 = thirteen_twelfths*(v2-2.d0*v3+v4)**2
     &   + one_fourth*(v2-v4)**2
      S3 = thirteen_twelfths*(v3-2.d0*v4+v5)**2
     &   + one_fourth*(3.d0*v3-4.d0*v4+v5)**2

c     Compute normalized weights
      a1 = 0.1d0/(S1+eps)**2
      a2 = 0.6d0/(S2+eps)**2
      a3 = 0.3d0/(S3+eps)**2
      inv_sum_a = 1.0d0 / (a1 + a2 + a3)
      a1 = a1*inv_sum_a
      a2 = a2*inv_sum_a
      a3 = a3*inv_sum_a

c     Compute grad_phi_x_plus
      grad_phi_x_plus =
     &    a1*grad_phi_1 + a2*grad_phi_2 + a3*grad_phi_3

c     --- Compute grad_phi_y

c     ------ Compute grad_phi_y_minus

c     Compute first-order finite differences for WENO5 calculation
      v1 = (phi(i,j-2,k) - phi(i,j-3,k)) / dx(2)
      v2 = (phi(i,j-1,k) - phi(i,j-2,k)) / dx(2)
      v3 = (phi(i,j,k) - phi(i,j-1,k)) / dx(2)
      v4 = (phi(i,j+1,k) - phi(i,j,k)) / dx(2)
      v5 = (phi(i,j+2,k) - phi(i,j+1,k)) / dx(2)

c     Compute eps for current grid point
      eps = 1e-6*max(v1*v1, v2*v2, v3*v3, v4*v4, v5*v5)
     &    + tiny_nonzero_number

c     Compute grad_phi_1, grad_phi_2, grad_phi_3
      grad_phi_1 = one_third*v1 - seven_sixths*v2 + eleven_sixths*v3
      grad_phi_2 = -one_sixth*v2 + five_sixths*v3 + one_third*v4
      grad_phi_3 = one_third*v3 + five_sixths*v4 - one_sixth*v5

c     Compute WENO5 smoothness measures
      S1 = thirteen_twelfths*(v1-2.d0*v2+v3)**2
     &   + one_fourth*(v1-4.d0*v2+3.d0*v3)**2
      S2 = thirteen_twelfths*(v2-2.d0*v3+v4)**2
     &   + one_fourth*(v2-v4)**2
      S3 = thirteen_twelfths*(v3-2.d0*v4+v5)**2
     &   + one_fourth*(3.d0*v3-4.d0*v4+v5)**2

c     Compute normalized weights
      a1 = 0.1d0/(S1+eps)**2
      a2 = 0.6d0/(S2+eps)**2
      a3 = 0.3d0/(S3+eps)**2
      inv_sum_a = 1.0d0 / (a1 + a2 + a3)
      a1 = a1*inv_sum_a
      a2 = a2*inv_sum_a
      a3 = a3*inv_sum_a

c     Compute grad_phi_y_minus
      grad_phi_y_minus =
     &    a1*grad_phi_1 + a2*grad_phi_2 + a3*grad_phi_3

c     ------ Compute grad_phi_y_plus

c     Compute first-order finite differences for WENO5 calculation
c
c     Note: we can reuse values used to compute grad_phi_y_minus

      v1 = (phi(i,j+3,k) - phi(i,j+2,k)) / dx(2)

      v_swap = v2
      v2 = v5
      v5 = v_swap

      v_swap = v3
      v3 = v4
      v4 = v_swap

c     Compute eps for current grid point
      eps = 1e-6*max(v1*v1, v2*v2, v3*v3, v4*v4, v5*v5)
     &    + tiny_nonzero_number

c     Compute grad_phi_1, grad_phi_2, grad_phi_3
      grad_phi_1 = one_third*v1 - seven_sixths*v2 + eleven_sixths*v3
      grad_phi_2 = -one_sixth*v2 + five_sixths*v3 + one_third*v4
      grad_phi_3 = one_third*v3 + five_sixths*v4 - one_sixth*v5

c     Compute WENO5 smoothness measures
      S1 = thirteen_twelfths*(v1-2.d0*v2+v3)**2
     &   + one_fourth*(v1-4.d0*v2+3.d0*v3)**2
      S2 = thirteen_twelfths*(v2-2.d0*v3+v4)**2
     &   + one_fourth*(v2-v4)**2
      S3 = thirteen_twelfths*(v3-2.d0*v4+v5)**2
     &   + one_fourth*(3.d0*v3-4.d0*v4+v5)**2

c     Compute normalized weights
      a1 = 0.1d0/(S1+eps)**2
      a2 = 0.6d0/(S2+eps)**2
      a3 = 0.3d0/(S3+eps)**2
      inv_sum_a = 1.0d0 / (a1 + a2 + a3)
      a1 = a1*inv_sum_a
      a2 = a2*inv_sum_a
      a3 = a3*inv_sum_a

c     Compute grad_phi_y_plus
      grad_phi_y_plus =
     &    a1*grad_phi_1 + a2*grad_phi_2 + a3*grad_phi_3

c     --- Compute grad_phi_z

c     ------ Compute grad_phi_z_minus

c     Compute first-order finite differences for WENO5 calculation
      v1 = (phi(i,j,k-2) - phi(i,j,k-3)) / dx(3)
      v2 = (phi(i,j,k-1) - phi(i,j,k-2)) / dx(3)
      v3 = (phi(i,j,k) - phi(i,j,k-1)) / dx(3)
      v4 = (phi(i,j,k+1) - phi(i,j,k)) / dx(3)
      v5 = (phi(i,j,k+2) - phi(i,j,k+1)) / dx(3)

c     Compute eps for current grid point
      eps = 1e-6*max(v1*v1, v2*v2, v3*v3, v4*v4, v5*v5)
     &    + tiny_nonzero_number

c     Compute grad_phi_1, grad_phi_2, grad_phi_3
      grad_phi_1 = one_third*v1 - seven_sixths*v2 + eleven_sixths*v3
      grad_phi_2 = -one_sixth*v2 + five_sixths*v3 + one_third*v4
      grad_phi_3 = one_third*v3 + five_sixths*v4 - one_sixth*v5

c     Compute WENO5 smoothness measures
      S1 = thirteen_twelfths*(v1-2.d0*v2+v3)**2
     &   + one_fourth*(v1-4.d0*v2+3.d0*v3)**2
      S2 = thirteen_twelfths*(v2-2.d0*v3+v4)**2
     &   + one_fourth*(v2-v4)**2
      S3 = thirteen_twelfths*(v3-2.d0*v4+v5)**2
     &   + one_fourth*(3.d0*v3-4.d0*v4+v5)**2

c     Compute normalized weights
      a1 = 0.1d0/(S1+eps)**2
      a2 = 0.6d0/(S2+eps)**2
      a3 = 0.3d0/(S3+eps)**2
      inv_sum_a = 1.0d0 / (a1 + a2 + a3)
      a1 = a1*inv_sum_a
      a2 = a2*inv_sum_a
      a3 = a3*inv_sum_a

c     Compute grad_phi_z_minus
      grad_phi_z_minus =
     &    a1*grad_phi_1 + a2*grad_phi_2 + a3*grad_phi_3

c     ------ Compute grad_phi_z_plus

c     Compute first-order finite differences for WENO5 calculation
c
c     Note: we can reuse values used to compute grad_phi_z_minus

      v1 = (phi(i,j,k+3) - phi(i,j,k+2)) / dx(3)

      v_swap = v2
      v2 = v5
      v5 = v_swap

      v_swap = v3
      v3 = v4
      v4 = v_swap

c     Compute eps for current grid point
      eps = 1e-6*max(v1*v1, v2*v2, v3*v3, v4*v4, v5*v5)
     &    + tiny_nonzero_number

c     Compute grad_phi_1, grad_phi_2, grad_phi_3
      grad_phi_1 = one_third*v1 - seven_sixths*v2 + eleven_sixths*v3
      grad_phi_2 = -one_sixth*v2 + five_sixths*v3 + one_third*v4
      grad_phi_3 = one_third*v3 + five_sixths*v4 - one_sixth*v5

c     Compute WENO5 smoothness measures
      S1 = thirteen_twelfths*(v1-2.d0*v2+v3)**2
     &   + one_fourth*(v1-4.d0*v2+3.d0*v3)**2
      S2 = thirteen_twelfths*(v2-2.d0*v3+v4)**2
     &   + one_fourth*(v2-v4)**2
      S3 = thirteen_twelfths*(v3-2.d0*v4+v5)**2
     &   + one_fourth*(3.d0*v3-4.d0*v4+v5)**2

c     Compute normalized weights
      a1 = 0.1d0/(S1+eps)**2
      a2 = 0.6d0/(S2+eps)**2
      a3 = 0.3d0/(S3+eps)**2
      inv_sum_a = 1.0d0 / (a1 + a2 + a3)
      a1 = a1*inv_sum_a
      a2 = a2*inv_sum_a
      a3 = a3*inv_sum_a

c     Compute grad_phi_z_plus
      grad_phi_y_plus =
     &    a1*grad_phi_1 + a2*grad_phi_2 + a3*grad_phi_3

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute the mean curvature of phi.
c
c   curvature = ( phi_xx * phi_y^2
c               - 2 * phi_xy * phi_x * phi_y
c               + phi_yy * phi_x^2
c               + phi_xx * phi_z^2
c               - 2 * phi_xz * phi_x * phi_z
c               + phi_zz * phi_x^2
c               + phi_yy * phi_z^2
c               - 2 * phi_yz * phi_y * phi_z
c               + phi_zz * phi_y^2 )
c             / |\nabla phi|^3
c
c Parameters
c ----------
c phi: function to compute mean curvature of
c
c dx: array containing grid spacing in each coordinate direction
c
c idx: array containing index of grid point to compute curvature at
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      @REAL@ function pqsMath3dMeanCurvature(
     &  phi, phi_gb_lo, phi_gb_hi,
     &  dx,
     &  idx)
c***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      real*8 dx(1:3)
      integer idx(1:3)

      @REAL@ phi_x, phi_y, phi_z
      @REAL@ phi_xx, phi_xy, phi_xz, phi_yy, phi_yz, phi_zz
      @REAL@ norm_grad_phi_sq
      integer i, j, k

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

c     Preparations
      i = idx(1)
      j = idx(2)
      k = idx(3)

c     Compute gradients and Hessian
      phi_x = 0.5 * (phi(i+1,j,k) - phi(i-1,j,k)) / dx(1)
      phi_y = 0.5 * (phi(i,j+1,k) - phi(i,j-1,k)) / dx(2)
      phi_z = 0.5 * (phi(i,j,k+1) - phi(i,j,k-1)) / dx(3)

      phi_xx = (phi(i+1,j,k) - 2*phi(i,j,k) + phi(i-1,j,k)) / dx(1)**2
      phi_yy = (phi(i,j+1,k) - 2*phi(i,j,k) + phi(i,j-1,k)) / dx(2)**2
      phi_zz = (phi(i,j,k+1) - 2*phi(i,j,k) + phi(i,j,k-1)) / dx(3)**2

      phi_xy = 0.25 *
     &         ( phi(i+1,j+1,k) - phi(i-1,j+1,k)
     &         - phi(i+1,j-1,k) + phi(i-1,j-1,k) ) / (dx(1) * dx(2))
      phi_xz = 0.25 *
     &         ( phi(i+1,j,k+1) - phi(i-1,j,k+1)
     &         - phi(i+1,j,k-1) + phi(i-1,j,k-1) ) / (dx(1) * dx(3))
      phi_yz = 0.25 *
     &         ( phi(i,j+1,k+1) - phi(i,j-1,k+1)
     &         - phi(i,j+1,k-1) + phi(i,j-1,k-1) ) / (dx(2) * dx(3))

c     Compute mean curvature
      norm_grad_phi_sq = phi_x**2 + phi_y**2 + phi_z**2

      if (norm_grad_phi_sq .lt. zero_tol) then
          pqsMath3dMeanCurvature = 0.d0
      else
          pqsMath3dMeanCurvature = ( phi_xx * phi_y**2
     &                             - 2 * phi_xy * phi_x * phi_y
     &                             + phi_yy * phi_x**2
     &                             + phi_xx * phi_z**2
     &                             - 2 * phi_xz * phi_x * phi_z
     &                             + phi_zz * phi_x**2
     &                             + phi_yy * phi_z**2
     &                             - 2 * phi_yz * phi_y * phi_z
     &                             + phi_zz * phi_y**2 )
     &                           / norm_grad_phi_sq**(1.5)

      endif

      return
      end
c } end function
c***********************************************************************
