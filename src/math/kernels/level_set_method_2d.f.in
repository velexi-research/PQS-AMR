c***********************************************************************
c
c level_set_method_2d.f
c
c F77 routines for Level Set Method computations in two space dimensions
c
c***********************************************************************

c***********************************************************************
c
c Compute area of region where level set function is less than 0.
c
c Parameters
c ----------
c phi: level set function
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: numerical width Heaviside function (as a function of phi)
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c Return value
c ------------
c area of region where phi < 0
c
c Notes
c -----
c - When phi is a signed distance function, the numerical width of the
c   Heaviside function as a function of spatial position is approximately
c   equal to (2 * eps).
c
c***********************************************************************
      @REAL@ function lsm2dAreaPhiLessThanZero(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)
      real*8 dx(1:2)
      real*8 eps

      integer i, j
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 one_minus_H
      real*8 dA
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)

      real*8 area

c     compute dA
      dA = dx(1) * dx(2)

c     initialize area to zero
      area = 0.0d0

c     loop over patch box {
      do j=patch_box_lo(2),patch_box_hi(2)
        do i=patch_box_lo(1),patch_box_hi(1)

          phi_cur = phi(i,j)

          if (phi_cur .lt. -eps) then

            area = area + dA

          elseif (phi_cur .lt.  eps) then

            phi_cur_over_eps = phi_cur/eps

            one_minus_H = 0.5d0*( 1 - phi_cur_over_eps
     &                              - one_over_pi
     &                               *sin(pi*phi_cur_over_eps))

            area = area + one_minus_H*dA

          endif

        enddo
      enddo
c     } end loop over patch box

c     set result
      lsm2dAreaPhiLessThanZero = area

      return
      end
c } end function
c***********************************************************************

c***********************************************************************
c
c Compute area of region where level set function is greater
c than 0.
c
c Parameters
c ----------
c phi: level set function
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: numerical width Heaviside function (as a function of phi)
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c Return value
c ------------
c area of region where phi > 0
c
c Notes
c -----
c - When phi is a signed distance function, the numerical width of the
c   Heaviside function as a function of spatial position is approximately
c   equal to (2 * eps).
c
c***********************************************************************
      @REAL@ function lsm2dAreaPhiGreaterThanZero(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)
      real*8 dx(1:2)
      real*8 eps

      integer i, j
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 H
      real*8 dA
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)

      real*8 area

c     compute dA
      dA = dx(1) * dx(2)

c     initialize area to zero
      area = 0.0d0

c     loop over patch box {
      do j=patch_box_lo(2),patch_box_hi(2)
        do i=patch_box_lo(1),patch_box_hi(1)

          phi_cur = phi(i,j)

          if (phi_cur .gt. eps) then

            area = area + dA

          elseif (phi_cur .gt.  -eps) then

            phi_cur_over_eps = phi_cur/eps

            H = 0.5d0*( 1 + phi_cur_over_eps
     &                    + one_over_pi*sin(pi*phi_cur_over_eps))

            area = area + H*dA

          endif

        enddo
      enddo
c     } end loop over patch box

c     set result
      lsm2dAreaPhiGreaterThanZero = area

      return
      end
c } end function
c***********************************************************************

c***********************************************************************
c
c Compute the right-hand side of the reinitialization equation using
c a Godunov scheme to select the numerical discretization of the
c sgn(phi_0) |grad(phi)| term.
c
c Parameters
c ----------
c rhs: [output] right-hand side of reinitialization equation
c
c phi: level set function at current iteration of reinitialization
c      process
c
c phi_0: level set function at initial iteration of reinitialization
c      process
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c***********************************************************************
      subroutine lsm2dComputeReinitializationEqnRHS(
     &  rhs, &  rhs_gb_lo, rhs_gb_hi,
     &  phi, phi_gb_lo, phi_gb_hi,
     &  phi_0, phi_0_gb_lo, phi_0_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx)
c***********************************************************************
c { begin subroutine
      implicit none

      integer ilo_rhs_gb, ihi_rhs_gb, jlo_rhs_gb, jhi_rhs_gb
      integer ilo_phi_gb, ihi_phi_gb, jlo_phi_gb, jhi_phi_gb
      integer ilo_phi_0_gb, ihi_phi_0_gb, jlo_phi_0_gb, jhi_phi_0_gb
      integer ilo_grad_phi_plus_gb, ihi_grad_phi_plus_gb
      integer jlo_grad_phi_plus_gb, jhi_grad_phi_plus_gb
      integer ilo_grad_phi_minus_gb, ihi_grad_phi_minus_gb
      integer jlo_grad_phi_minus_gb, jhi_grad_phi_minus_gb
      integer ilo_patch_box, ihi_patch_box, jlo_patch_box, jhi_patch_box
      real reinit_rhs(ilo_rhs_gb:ihi_rhs_gb,
     &                jlo_rhs_gb:jhi_rhs_gb)
      real phi(ilo_phi_gb:ihi_phi_gb,
     &         jlo_phi_gb:jhi_phi_gb)
      real phi_0(ilo_phi_0_gb:ihi_phi_0_gb,
     &          jlo_phi_0_gb:jhi_phi_0_gb)
      real phi_x_plus(ilo_grad_phi_plus_gb:ihi_grad_phi_plus_gb,
     &                jlo_grad_phi_plus_gb:jhi_grad_phi_plus_gb)
      real phi_y_plus(ilo_grad_phi_plus_gb:ihi_grad_phi_plus_gb,
     &                jlo_grad_phi_plus_gb:jhi_grad_phi_plus_gb)
      real phi_x_minus(ilo_grad_phi_minus_gb:ihi_grad_phi_minus_gb,
     &                 jlo_grad_phi_minus_gb:jhi_grad_phi_minus_gb)
      real phi_y_minus(ilo_grad_phi_minus_gb:ihi_grad_phi_minus_gb,
     &                 jlo_grad_phi_minus_gb:jhi_grad_phi_minus_gb)
      real dx, dy
      real phi_cur
      integer DIM
      parameter (DIM=2)
      real grad_phi_plus_cur(1:DIM)
      real grad_phi_minus_cur(1:DIM)
      real grad_phi_star(1:DIM)
      integer i,j
      integer dir
      real sgn_phi
      real norm_grad_phi_sq
      real dx_sq
      real zero_tol
      parameter (zero_tol=@ZERO_TOL@)
      real one
      parameter (one=1.d0)

c     set value of dx_sq to be square of max{dx,dy}
      dx_sq = max(dx,dy)
      dx_sq = dx_sq*dx_sq

c----------------------------------------------------
c      compute RHS of reinitialization equation
c      using Godunov's method
c----------------------------------------------------

c     { begin loop over grid
      do j=jlo_patch_box,jhi_patch_box
        do i=ilo_patch_box,ihi_patch_box

c         cache phi and spatial derivative approximations
          phi_cur = phi_0(i,j)
          grad_phi_plus_cur(1) = phi_x_plus(i,j)
          grad_phi_plus_cur(2) = phi_y_plus(i,j)
          grad_phi_minus_cur(1) = phi_x_minus(i,j)
          grad_phi_minus_cur(2) = phi_y_minus(i,j)

c         { begin Godunov selection of grad_phi
          do dir=1,DIM

            if (phi_cur .gt. 0.d0) then
              grad_phi_plus_cur(dir) = max(-grad_phi_plus_cur(dir),
     &                                     0.d0)
              grad_phi_minus_cur(dir) = max(grad_phi_minus_cur(dir),
     &                                      0.d0)
            else
              grad_phi_plus_cur(dir) = max(grad_phi_plus_cur(dir),
     &                                     0.d0)
              grad_phi_minus_cur(dir) = max(-grad_phi_minus_cur(dir),
     &                                      0.d0)
            endif

            grad_phi_star(dir) = max(grad_phi_plus_cur(dir),
     &                               grad_phi_minus_cur(dir)) 

          enddo
c         } end Godunov selection of phi_y in y-direction

c         compute reinit_rhs(i,j) using smoothed sgn(phi)
          if (abs(phi_cur) .gt. zero_tol) then
            norm_grad_phi_sq = grad_phi_star(1)*grad_phi_star(1)
     &                       + grad_phi_star(2)*grad_phi_star(2)
            sgn_phi = phi_cur / sqrt(phi_cur*phi_cur + dx_sq)
            reinit_rhs(i,j) = sgn_phi*(one - sqrt(norm_grad_phi_sq))
          else
            reinit_rhs(i,j) = 0.d0
          endif

        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute the right-hand side of the reinitialization equation using
c a Godunov scheme to select the numerical discretization of the
c sgn(phi_0) |grad(phi)| term.
c
c Parameters
c ----------
c rhs: [output] right-hand side of reinitialization equation
c
c phi: level set function at current iteration of reinitialization
c      process
c
c phi_*_plus (in):        forward spatial derivatives for grad(phi)
c
c phi_*_minus (in):       backward spatial derivatives for grad(phi)
c
c *_gb (in):              index range for ghost box
c *_patch_box (in):              index range for patch box
c
c***********************************************************************
      subroutine lsm2dComputeReinitializationEqnRHSPeng(
     &  rhs,
     &  ilo_rhs_gb, ihi_rhs_gb, jlo_rhs_gb, jhi_rhs_gb,
     &  phi,
     &  ilo_phi_gb, ihi_phi_gb, jlo_phi_gb, jhi_phi_gb,
     &  ilo_patch_box, ihi_patch_box, jlo_patch_box, jhi_patch_box,
     &  dx)
c***********************************************************************
c { begin subroutine
      implicit none

      integer ilo_rhs_gb, ihi_rhs_gb, jlo_rhs_gb, jhi_rhs_gb
      integer ilo_phi_gb, ihi_phi_gb, jlo_phi_gb, jhi_phi_gb
      integer ilo_grad_phi_plus_gb, ihi_grad_phi_plus_gb
      integer jlo_grad_phi_plus_gb, jhi_grad_phi_plus_gb
      integer ilo_grad_phi_minus_gb, ihi_grad_phi_minus_gb
      integer jlo_grad_phi_minus_gb, jhi_grad_phi_minus_gb
      integer ilo_patch_box, ihi_patch_box, jlo_patch_box, jhi_patch_box
      real reinit_rhs(ilo_rhs_gb:ihi_rhs_gb,
     &                jlo_rhs_gb:jhi_rhs_gb)
      real phi(ilo_phi_gb:ihi_phi_gb,
     &         jlo_phi_gb:jhi_phi_gb)
      real phi_x_plus(ilo_grad_phi_plus_gb:ihi_grad_phi_plus_gb,
     &                jlo_grad_phi_plus_gb:jhi_grad_phi_plus_gb)
      real phi_y_plus(ilo_grad_phi_plus_gb:ihi_grad_phi_plus_gb,
     &                jlo_grad_phi_plus_gb:jhi_grad_phi_plus_gb)
      real phi_x_minus(ilo_grad_phi_minus_gb:ihi_grad_phi_minus_gb,
     &                 jlo_grad_phi_minus_gb:jhi_grad_phi_minus_gb)
      real phi_y_minus(ilo_grad_phi_minus_gb:ihi_grad_phi_minus_gb,
     &                 jlo_grad_phi_minus_gb:jhi_grad_phi_minus_gb)
      real dx, dy
      real phi_cur
      integer DIM
      parameter (DIM=2)
      real grad_phi_plus_cur(1:DIM)
      real grad_phi_minus_cur(1:DIM)
      real grad_phi_star(1:DIM)
      integer i,j
      integer dir
      real sgn_phi
      real norm_grad_phi_sq
      real dx_sq
      real zero_tol
      parameter (zero_tol=@ZERO_TOL@)
      real one
      parameter (one=1.d0)

c     set value of dx_sq to be square of max{dx,dy}
      dx_sq = max(dx,dy)
      dx_sq = dx_sq*dx_sq

c----------------------------------------------------
c      compute RHS of reinitialization equation
c      using Godunov's method
c----------------------------------------------------

c     { begin loop over grid
      do j=jlo_patch_box,jhi_patch_box
        do i=ilo_patch_box,ihi_patch_box

c         cache phi and spatial derivative approximations
          phi_cur = phi(i,j)
          grad_phi_plus_cur(1) = phi_x_plus(i,j)
          grad_phi_plus_cur(2) = phi_y_plus(i,j)
          grad_phi_minus_cur(1) = phi_x_minus(i,j)
          grad_phi_minus_cur(2) = phi_y_minus(i,j)

c         Compute forward and backward approximations of (phi)
          idx(1) = i
          idx(2) = j
          call pqsMath2dComputeGradENO1(
     &      grad_phi_x_plus, grad_phi_x_minus,
     &      grad_phi_y_plus, grad_phi_y_minus,
     &      phi, phi_gb_lo, phi_gb_hi,
     &      dx, idx)

c         { begin Godunov selection of grad_phi
          do dir=1,DIM

            if (phi_cur .gt. 0.d0) then
              grad_phi_plus_cur(dir) = max(-grad_phi_plus_cur(dir),
     &                                     0.d0)
              grad_phi_minus_cur(dir) = max(grad_phi_minus_cur(dir),
     &                                      0.d0)
            else
              grad_phi_plus_cur(dir) = max(grad_phi_plus_cur(dir),
     &                                     0.d0)
              grad_phi_minus_cur(dir) = max(-grad_phi_minus_cur(dir),
     &                                      0.d0)
            endif

            grad_phi_star(dir) = max(grad_phi_plus_cur(dir),
     &                               grad_phi_minus_cur(dir)) 

          enddo
c         } end Godunov selection of grad_phi

c         compute reinit_rhs(i,j) using smoothed sgn(phi)
          if (abs(phi_cur) .gt. zero_tol) then 
            norm_grad_phi_sq = grad_phi_star(1)*grad_phi_star(1)
     &                       + grad_phi_star(2)*grad_phi_star(2)
            sgn_phi = phi_cur
     &              / sqrt(phi_cur*phi_cur + norm_grad_phi_sq*dx_sq)
            reinit_rhs(i,j) = sgn_phi*(one - sqrt(norm_grad_phi_sq))
          else
            reinit_rhs(i,j) = 0.d0
          endif

        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************
