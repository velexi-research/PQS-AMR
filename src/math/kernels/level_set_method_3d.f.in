c***********************************************************************
c
c level_set_method_3d.f
c
c F77 routines for Level Set Method computations in three space
c dimensions
c
c***********************************************************************

c***********************************************************************
c
c Compute volume of region where level set function is less than 0.
c
c Parameters
c ----------
c phi: level set function
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: numerical width Heaviside function (as a function of phi)
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c Return value
c ------------
c volume of region where phi < 0
c
c Notes
c -----
c - When phi is a signed distance function, the numerical width of the
c   Heaviside function as a function of spatial position is approximately
c   equal to (2 * eps).
c
c***********************************************************************
      @REAL@ function lsm3dVolumePhiLessThanZero(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer patch_box_lo(1:3), patch_box_hi(1:3)
      real*8 dx(1:3)
      real*8 eps

      integer i, j, k
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 one_minus_H
      real*8 dV
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)

      real*8 volume

c     compute dV
      dV = dx(1) * dx(2) * dx(3)

c     initialize volume to zero
      volume = 0.0d0

c     loop over patch box {
      do k=patch_box_lo(3),patch_box_hi(3)
        do j=patch_box_lo(2),patch_box_hi(2)
          do i=patch_box_lo(1),patch_box_hi(1)

            phi_cur = phi(i,j,k)

            if (phi_cur .lt. -eps) then

              volume = volume + dV

            elseif (phi_cur .lt.  eps) then

              phi_cur_over_eps = phi_cur/eps

              one_minus_H = 0.5d0*( 1 - phi_cur_over_eps
     &                                - one_over_pi
     &                                 *sin(pi*phi_cur_over_eps))

              volume = volume + one_minus_H*dV

            endif

          enddo
        enddo
      enddo
c     } end loop over patch box

c     set result
      lsm3dVolumePhiLessThanZero = volume

      return
      end
c } end function
c***********************************************************************

c***********************************************************************
c
c Compute volume of region where level set function is less than 0 where
c control volume is non-zero.
c
c Parameters
c ----------
c phi: level set function
c
c control_volume: control volume
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: numerical width Heaviside function (as a function of phi)
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c Return value
c ------------
c volume of region where phi < 0 where control volume is non-zero
c
c Notes
c -----
c - When phi is a signed distance function, the numerical width of the
c   Heaviside function as a function of spatial position is approximately
c   equal to (2 * eps).
c
c - Control volume is considered non-zero when it is greater than
c   zero_tol.
c
c***********************************************************************
      @REAL@ function lsm3dVolumePhiLessThanZeroWithControlVolume(
     &  phi, phi_gb_lo, phi_gb_hi,
     &  control_volume, control_volume_gb_lo, control_volume_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer control_volume_gb_lo(1:3), control_volume_gb_hi(1:3)
      @REAL@ control_volume(
     &      control_volume_gb_lo(1):control_volume_gb_hi(1),
     &      control_volume_gb_lo(2):control_volume_gb_hi(2),
     &      control_volume_gb_lo(3):control_volume_gb_hi(3))

      integer patch_box_lo(1:3), patch_box_hi(1:3)
      real*8 dx(1:3)
      real*8 eps

      integer i, j, k
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 one_minus_H
      real*8 dV
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)
      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

      real*8 volume

c     compute dV
      dV = dx(1) * dx(2) * dx(3)

c     initialize volume to zero
      volume = 0.0d0

c     loop over patch box {
      do k=patch_box_lo(3),patch_box_hi(3)
        do j=patch_box_lo(2),patch_box_hi(2)
          do i=patch_box_lo(1),patch_box_hi(1)
            if (control_volume(i,j,k) .gt. zero_tol) then

              phi_cur = phi(i,j,k)

              if (phi_cur .lt. -eps) then

                volume = volume + dV

              elseif (phi_cur .lt.  eps) then

                phi_cur_over_eps = phi_cur/eps

                one_minus_H = 0.5d0*( 1 - phi_cur_over_eps
     &                                  - one_over_pi
     &                                   *sin(pi*phi_cur_over_eps))

                volume = volume + one_minus_H*dV

              endif

            endif
          enddo
        enddo
      enddo
c     } end loop over patch box

c     set result
      lsm3dVolumePhiLessThanZeroWithControlVolume = volume

      return
      end
c } end function
c***********************************************************************

c***********************************************************************
c
c Compute volume of region where level set function is greater
c than 0.
c
c Parameters
c ----------
c phi: level set function
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: numerical width Heaviside function (as a function of phi)
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c Return value
c ------------
c volume of region where phi > 0
c
c Notes
c -----
c - When phi is a signed distance function, the numerical width of the
c   Heaviside function as a function of spatial position is approximately
c   equal to (2 * eps).
c
c***********************************************************************
      @REAL@ function lsm3dVolumePhiGreaterThanZero(
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer patch_box_lo(1:3), patch_box_hi(1:3)
      real*8 dx(1:3)
      real*8 eps

      integer i, j, k
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 H
      real*8 dV
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)

      real*8 volume

c     compute dV
      dV = dx(1) * dx(2) * dx(3)

c     initialize volume to zero
      volume = 0.0d0

c     loop over patch box {
      do k=patch_box_lo(3),patch_box_hi(3)
        do j=patch_box_lo(2),patch_box_hi(2)
          do i=patch_box_lo(1),patch_box_hi(1)

            phi_cur = phi(i,j,k)

            if (phi_cur .gt. eps) then

              volume = volume + dV

            elseif (phi_cur .gt.  -eps) then

              phi_cur_over_eps = phi_cur/eps

              H = 0.5d0*( 1 + phi_cur_over_eps
     &                      + one_over_pi*sin(pi*phi_cur_over_eps))

              volume = volume + H*dV

          endif

          enddo
        enddo
      enddo
c     } end loop over patch box

c     set result
      lsm3dVolumePhiGreaterThanZero = volume

      return
      end
c } end function
c***********************************************************************

c***********************************************************************
c
c Compute volume of region where level set function is greater
c than 0 where c control volume is non-zero.
c
c Parameters
c ----------
c phi: level set function
c
c control_volume: control volume
c
c dx: array containing grid spacing in each coordinate direction
c
c eps: numerical width Heaviside function (as a function of phi)
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c Return value
c ------------
c volume of region where phi > 0 where control volume is non-zero
c
c Notes
c -----
c - When phi is a signed distance function, the numerical width of the
c   Heaviside function as a function of spatial position is approximately
c   equal to (2 * eps).
c
c - Control volume is considered non-zero when it is greater than
c   zero_tol.
c
c***********************************************************************
      @REAL@ function lsm3dVolumePhiGreaterThanZeroWithControlVolume(
     &  phi, phi_gb_lo, phi_gb_hi,
     &  control_volume, control_volume_gb_lo, control_volume_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  eps)
***********************************************************************
c { begin function
      implicit none

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer control_volume_gb_lo(1:3), control_volume_gb_hi(1:3)
      @REAL@ control_volume(
     &      control_volume_gb_lo(1):control_volume_gb_hi(1),
     &      control_volume_gb_lo(2):control_volume_gb_hi(2),
     &      control_volume_gb_lo(3):control_volume_gb_hi(3))

      integer patch_box_lo(1:3), patch_box_hi(1:3)
      real*8 dx(1:3)
      real*8 eps

      integer i, j, k
      real*8 phi_cur
      real*8 phi_cur_over_eps
      real*8 H
      real*8 dV
      real*8 pi
      parameter (pi=3.14159265358979323846d0)
      real*8 one_over_pi
      parameter (one_over_pi=0.31830988618379d0)
      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

      real*8 volume

c     compute dV
      dV = dx(1) * dx(2) * dx(3)

c     initialize volume to zero
      volume = 0.0d0

c     loop over patch box {
      do k=patch_box_lo(3),patch_box_hi(3)
        do j=patch_box_lo(2),patch_box_hi(2)
          do i=patch_box_lo(1),patch_box_hi(1)
            if (control_volume(i,j,k) .gt. zero_tol) then

              phi_cur = phi(i,j,k)

              if (phi_cur .gt. eps) then

                volume = volume + dV

              elseif (phi_cur .gt.  -eps) then

                phi_cur_over_eps = phi_cur/eps

                H = 0.5d0*( 1 + phi_cur_over_eps
     &                        + one_over_pi*sin(pi*phi_cur_over_eps))

                volume = volume + H*dV

              endif

            endif
          enddo
        enddo
      enddo
c     } end loop over patch box

c     set result
      lsm3dVolumePhiGreaterThanZeroWithControlVolume = volume

      return
      end
c } end function
c***********************************************************************

c***********************************************************************
c
c Compute the right-hand side of the reinitialization equation using
c sgn(phi_0) in hyperbolic term of the reinitialization equation.
c
c Parameters
c ----------
c rhs: [output] right-hand side of reinitialization equation
c
c phi: level set function at current iteration of reinitialization
c      process
c
c phi_0: level set function at initial iteration of reinitialization
c      process
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c dx: array containing grid spacing in each coordinate direction
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c Notes
c -----
c * The formulation of the reinitialization equation that uses
c   sgn(phi_0) follows the development in Sussman et al (1994).
c
c * Uses a Godunov scheme to select the numerical discretization of the
c   sgn(phi_0) |grad(phi)| term.
c
c***********************************************************************
      subroutine lsm3dComputeReinitEqnSgnPhi0RHS(
     &  rhs, rhs_gb_lo, rhs_gb_hi,
     &  phi, phi_gb_lo, phi_gb_hi,
     &  phi_0, phi_0_gb_lo, phi_0_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx)
c***********************************************************************
c { begin subroutine
      implicit none

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer phi_0_gb_lo(1:3), phi_0_gb_hi(1:3)
      @REAL@ phi_0(phi_0_gb_lo(1):phi_0_gb_hi(1),
     &             phi_0_gb_lo(2):phi_0_gb_hi(2),
     &             phi_0_gb_lo(3):phi_0_gb_hi(3))

      integer patch_box_lo(1:3), patch_box_hi(1:3)
      real*8 dx(1:3)

      integer i, j, k
      integer dir
      integer idx(1:3)

      real dx_sq

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_z_plus, grad_phi_z_minus

      @REAL@ phi_0_cur
      @REAL@ grad_phi_x_star_sq
      @REAL@ grad_phi_y_star_sq
      @REAL@ grad_phi_z_star_sq

      @REAL@ sgn_phi_0
      @REAL@ norm_grad_phi_sq

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)
      @REAL@ one
      parameter (one=1.d0)

c     --- Preparations

c     set value of dx_sq to be square of max of grid spacing over all
c     coordinate directions
      dx_sq = maxval(dx)**2

c     --- Compute RHS of reinitialization equation using Godunov's method

c     { begin loop over grid
      do k=patch_box_lo(3),patch_box_hi(3)
        do j=patch_box_lo(2),patch_box_hi(2)
          do i=patch_box_lo(1),patch_box_hi(1)

            phi_0_cur = phi_0(i,j,k)

c           compute forward and backward approximations of grad(phi)
            idx(1) = i
            idx(2) = j
            idx(3) = k
            call pqsMath3dComputeGradENO1(
     &        grad_phi_x_plus, grad_phi_x_minus,
     &        grad_phi_y_plus, grad_phi_y_minus,
     &        grad_phi_z_plus, grad_phi_z_minus,
     &        phi, phi_gb_lo, phi_gb_hi,
     &        dx, idx)

c           { begin Godunov selection of grad_phi

c             Rouy and Tourin formula (1992)
            if (phi_0_cur .gt. 0.d0) then
              grad_phi_x_star_sq = max(
     &            max(grad_phi_x_minus,0.d0)**2,
     &            min(grad_phi_x_plus,0.d0)**2)

              grad_phi_y_star_sq = max(
     &            max(grad_phi_y_minus,0.d0)**2,
     &            min(grad_phi_y_plus,0.d0)**2)

              grad_phi_z_star_sq = max(
     &            max(grad_phi_z_minus,0.d0)**2,
     &            min(grad_phi_z_plus,0.d0)**2)
            else
              grad_phi_x_star_sq = max(
     &            min(grad_phi_x_minus,0.d0)**2,
     &            max(grad_phi_x_plus,0.d0)**2)

              grad_phi_y_star_sq = max(
     &            min(grad_phi_y_minus,0.d0)**2,
     &            max(grad_phi_y_plus,0.d0)**2)

              grad_phi_z_star_sq = max(
     &            min(grad_phi_z_minus,0.d0)**2,
     &            max(grad_phi_z_plus,0.d0)**2)
            endif

c           } end Godunov selection of grad_phi

c           compute rhs(i,j,k) using smoothed sgn(phi)
            if (abs(phi_0_cur) .gt. zero_tol) then
            norm_grad_phi_sq = grad_phi_x_star_sq +
     &                         grad_phi_y_star_sq +
     &                         grad_phi_z_star_sq

              sgn_phi_0 = phi_0_cur / sqrt(phi_0_cur**2 + dx_sq)
              rhs(i,j,k) = sgn_phi_0 * (one - sqrt(norm_grad_phi_sq))
            else
              rhs(i,j,k) = 0.d0
            endif

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute the right-hand side of the reinitialization equation using
c sgn(phi) in hyperbolic term of the reinitialization equation.
c
c Parameters
c ----------
c rhs: [output] right-hand side of reinitialization equation
c
c phi: level set function
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c dx: array containing grid spacing in each coordinate direction
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c Notes
c -----
c * The formulation of the reinitialization equation that uses
c   sgn(phi) follows the development in Peng et al (1999).
c
c * Uses a Godunov scheme to select the numerical discretization of the
c   sgn(phi) |grad(phi)| term.
c
c***********************************************************************
      subroutine lsm3dComputeReinitEqnSgnPhiRHS(
     &  rhs, rhs_gb_lo, rhs_gb_hi,
     &  phi, phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx)
c***********************************************************************
c { begin subroutine
      implicit none

      integer rhs_gb_lo(1:3), rhs_gb_hi(1:3)
      @REAL@ rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &           rhs_gb_lo(2):rhs_gb_hi(2),
     &           rhs_gb_lo(3):rhs_gb_hi(3))

      integer phi_gb_lo(1:3), phi_gb_hi(1:3)
      @REAL@ phi(phi_gb_lo(1):phi_gb_hi(1),
     &           phi_gb_lo(2):phi_gb_hi(2),
     &           phi_gb_lo(3):phi_gb_hi(3))

      integer patch_box_lo(1:3), patch_box_hi(1:3)
      real*8 dx(1:3)

      integer i, j, k
      integer dir
      integer idx(1:3)

      real dx_sq

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_z_plus, grad_phi_z_minus

      @REAL@ phi_cur
      @REAL@ grad_phi_x_star_sq
      @REAL@ grad_phi_y_star_sq
      @REAL@ grad_phi_z_star_sq

      @REAL@ sgn_phi
      @REAL@ norm_grad_phi_sq

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)
      @REAL@ one
      parameter (one=1.d0)

c     --- Preparations

c     set value of dx_sq to be square of max of grid spacing over all
c     coordinate directions
      dx_sq = maxval(dx)**2

c     --- Compute RHS of reinitialization equation using Godunov's method

c     { begin loop over grid
      do k=patch_box_lo(3),patch_box_hi(3)
        do j=patch_box_lo(2),patch_box_hi(2)
          do i=patch_box_lo(1),patch_box_hi(1)

            phi_cur = phi(i,j,k)

c           compute forward and backward approximations of (phi)
            idx(1) = i
            idx(2) = j
            idx(3) = k
            call pqsMath3dComputeGradENO1(
     &        grad_phi_x_plus, grad_phi_x_minus,
     &        grad_phi_y_plus, grad_phi_y_minus,
     &        grad_phi_z_plus, grad_phi_z_minus,
     &        phi, phi_gb_lo, phi_gb_hi,
     &        dx, idx)

c           { begin Godunov selection of grad_phi

c           Rouy and Tourin formula (1992)
            if (phi_cur .gt. 0.d0) then
              grad_phi_x_star_sq = max(
     &            max(grad_phi_x_minus**2,0.d0),
     &            min(grad_phi_x_plus**2,0.d0))

              grad_phi_y_star_sq = max(
     &            max(grad_phi_y_minus**2,0.d0),
     &            min(grad_phi_y_plus**2,0.d0))

              grad_phi_z_star_sq = max(
     &            max(grad_phi_z_minus**2,0.d0),
     &            min(grad_phi_z_plus**2,0.d0))

            else
              grad_phi_x_star_sq = max(
     &            min(grad_phi_x_minus**2,0.d0),
     &            max(grad_phi_x_plus**2,0.d0))

              grad_phi_y_star_sq = max(
     &            min(grad_phi_y_minus**2,0.d0),
     &            max(grad_phi_y_plus**2,0.d0))

              grad_phi_z_star_sq = max(
     &            min(grad_phi_z_minus**2,0.d0),
     &            max(grad_phi_z_plus**2,0.d0))

            endif

c           } end Godunov selection of grad_phi

c           compute rhs(i,j,k) using smoothed sgn(phi)
            if (abs(phi_cur) .gt. zero_tol) then
            norm_grad_phi_sq = grad_phi_x_star_sq +
     &                         grad_phi_y_star_sq +
     &                         grad_phi_z_star_sq

              sgn_phi = phi_cur
     &                / sqrt(phi_cur**2 + norm_grad_phi_sq*dx_sq)
              rhs(i,j,k) = sgn_phi * (one - sqrt(norm_grad_phi_sq))
            else
              rhs(i,j,k) = 0.d0
            endif

          enddo
        enddo
      enddo
c     } end loop over grid

      return
      end
c } end subroutine
c***********************************************************************
