c***********************************************************************
c
c kernels_2d.f
c
c Subroutines for PQS models
c
c***********************************************************************

c***********************************************************************
c
c Compute RHS and maximum stable time step (on box) for Prescribed
c Curvature Model with zero contact angle.
c
c Parameters
c ----------
c max_stable_dt: [output] maximum stable time step for explicit time
c     integration schemes
c
c rhs: [output] right-hand side of level set evolution equation for
c     Prescribed Curvature Model
c
c phi: level set function that defines fluid-fluid interface
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c dx: array containing grid spacing in each coordinate direction
c
c pressure: reference pressure of non-wetting phase
c
c surface_tension: surface tension of interface between wetting
c     and non-wetting phases
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqs2dCurvatureModelZeroContactAngleRHS(
     &  max_stable_dt,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  pressure,
     &  surface_tension)
c***********************************************************************
c { begin subroutine
      implicit none

      real*8 max_stable_dt

      integer rhs_gb_lo(1:2), rhs_gb_hi(1:2)
      @REAL@  rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &            rhs_gb_lo(2):rhs_gb_hi(2))

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@  phi(phi_gb_lo(1):phi_gb_hi(1),
     &            phi_gb_lo(2):phi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)
      real*8 dx(1:2)

      real*8 pressure
      real*8 surface_tension

      integer i, j
      integer idx(1:2)

      @REAL@ mean_curvature, pqsMath2dMeanCurvature

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_x_centered, grad_phi_y_centered
      @REAL@ grad_phi_x_max, grad_phi_y_max
      @REAL@ norm_grad_phi

      real*8 stable_dt_local, stable_inv_dt_local

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

c     --- Preparations

      max_stable_dt = 1.0d37

c     --- Compute RHS on patch

      do j=patch_box_lo(2), patch_box_hi(2)
        do i=patch_box_lo(1), patch_box_hi(1)

c         --- Initialize rhs value

          rhs(i,j) = 0.0d0

c         --- Compute hyperbolic part of RHS

c         Compute forward and backward approximations of grad(phi)
          idx(1) = i
          idx(2) = j
          call pqsMath2dComputeGradENO1(
     &        grad_phi_x_plus, grad_phi_x_minus,
     &        grad_phi_y_plus, grad_phi_y_minus,
     &        phi,
     &        phi_gb_lo, phi_gb_hi,
     &        dx,
     &        idx)

c         Use Godunov's method to compute hyperbolic part of RHS
          if (abs(pressure) .gt. zero_tol) then
            if (pressure .gt. 0.d0) then
              norm_grad_phi = sqrt(
     &            max(max(grad_phi_x_minus,0.d0)**2,
     &                min(grad_phi_x_plus,0.d0)**2)
     &          + max(max(grad_phi_y_minus,0.d0)**2,
     &                min(grad_phi_y_plus,0.d0)**2))
            else
               norm_grad_phi = sqrt(
     &             max(min(grad_phi_x_minus,0.d0)**2,
     &                 max(grad_phi_x_plus,0.d0)**2)
     &           + max(min(grad_phi_y_minus,0.d0)**2,
     &                 max(grad_phi_y_plus,0.d0)**2))
            endif

            rhs(i,j) = rhs(i,j) - pressure * norm_grad_phi

          endif

c         --- Compute contribution to stable dt from hyperbolic part of RHS

          grad_phi_x_max = max(abs(grad_phi_x_plus),
     &                         abs(grad_phi_x_minus))
          grad_phi_y_max = max(abs(grad_phi_y_plus),
     &                         abs(grad_phi_y_minus))

c         Note: dx term included to avoid division by zero
c               in computation of stable_inv_dt_local
          norm_grad_phi = sqrt( grad_phi_x_max**2
     &                        + grad_phi_y_max**2
     &                        + max(dx(1), dx(2))**2 )

          stable_inv_dt_local =
     &        abs(pressure * grad_phi_x_max / norm_grad_phi) / dx(1)
     &      + abs(pressure * grad_phi_y_max / norm_grad_phi) / dx(2)

c         --- Compute parabolic part of normal velocity terms of RHS

c         Compute mean curvature
          mean_curvature =
     &        pqsMath2dMeanCurvature(phi, phi_gb_lo, phi_gb_hi,
     &                               dx, idx)

          grad_phi_x_centered = 0.5 * (phi(i+1,j) - phi(i-1,j)) / dx(1)
          grad_phi_y_centered = 0.5 * (phi(i,j+1) - phi(i,j-1)) / dx(2)
          norm_grad_phi = sqrt( grad_phi_x_centered**2
     &                        + grad_phi_y_centered**2 )

c         Compute contribution to RHS
          rhs(i,j) = rhs(i,j)
     &             + surface_tension * mean_curvature * norm_grad_phi

c         Compute contribution to stable dt from parabolic part of RHS
          stable_inv_dt_local = stable_inv_dt_local
     &                        + 2 * surface_tension / dx(1)**2
     &                        + 2 * surface_tension / dx(2)**2

c         --- Update maximum stable dt

          stable_dt_local = 1.0d0 / stable_inv_dt_local
          if (max_stable_dt .gt. stable_dt_local) then
            max_stable_dt = stable_dt_local
          endif

        enddo
      enddo

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute RHS and maximum stable time step (on box) for Prescribed
c Curvature Model with nonzero contact angle.
c
c Parameters
c ----------
c max_stable_dt: [output] maximum stable time step for explicit time
c     integration schemes
c
c rhs: [output] right-hand side of level set evolution equation for
c     Prescribed Curvature Model
c
c phi: level set function that defines fluid-fluid interface
c
c psi: level set function that defines solid-pore interface
c
c grad_psi: gradient of level set function that defines solid-pore
c     interface
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c dx: array containing grid spacing in each coordinate direction
c
c pressure: reference pressure of non-wetting phase
c
c surface_tension: surface tension of interface between wetting
c     and non-wetting phases
c
c contact_angle: contact angle between solid-pore interface and
c     the fluid-fluid interface
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqs2dCurvatureModelNonzeroContactAngleRHS(
     &  max_stable_dt,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  psi,
     &  psi_gb_lo, psi_gb_hi,
     &  grad_psi_x, grad_psi_y,
     &  grad_psi_gb_lo, grad_psi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  pressure,
     &  surface_tension,
     &  contact_angle)
c***********************************************************************
c { begin subroutine
      implicit none

      real*8 max_stable_dt

      integer rhs_gb_lo(1:2), rhs_gb_hi(1:2)
      @REAL@  rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &            rhs_gb_lo(2):rhs_gb_hi(2))

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@  phi(phi_gb_lo(1):phi_gb_hi(1),
     &            phi_gb_lo(2):phi_gb_hi(2))

      integer psi_gb_lo(1:2), psi_gb_hi(1:2)
      @REAL@  psi(psi_gb_lo(1):psi_gb_hi(1),
     &            psi_gb_lo(2):psi_gb_hi(2))

      integer grad_psi_gb_lo(1:2), grad_psi_gb_hi(1:2)
      @REAL@  grad_psi_x(grad_psi_gb_lo(1):grad_psi_gb_hi(1),
     &                   grad_psi_gb_lo(2):grad_psi_gb_hi(2))
      @REAL@  grad_psi_y(grad_psi_gb_lo(1):grad_psi_gb_hi(1),
     &                   grad_psi_gb_lo(2):grad_psi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)
      real*8 dx(1:2)

      real*8 pressure
      real*8 surface_tension
      real*8 contact_angle

      integer i, j
      integer idx(1:2)

      @REAL@ V_x_contact_angle
      @REAL@ V_y_contact_angle
      @REAL@ mean_curvature, pqsMath2dMeanCurvature

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_x_centered, grad_phi_y_centered
      @REAL@ grad_phi_x_max, grad_phi_y_max
      @REAL@ norm_grad_phi

      real*8 stable_dt_local, stable_inv_dt_local

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

c     --- Preparations

      max_stable_dt = 1.0d37

c     --- Compute RHS on patch

      do j=patch_box_lo(2), patch_box_hi(2)
        do i=patch_box_lo(1), patch_box_hi(1)

c         --- Initialize rhs value

          rhs(i,j) = 0.0d0

c         --- Compute hyperbolic part of RHS

c         Compute contact angle component of advective velocity
c         TODO
          V_x_contact_angle = 0.0d0
          V_y_contact_angle = 0.0d0

c         Compute forward and backward approximations of grad(phi)
          idx(1) = i
          idx(2) = j
          call pqsMath2dComputeGradENO1(
     &        grad_phi_x_plus, grad_phi_x_minus,
     &        grad_phi_y_plus, grad_phi_y_minus,
     &        phi,
     &        phi_gb_lo, phi_gb_hi,
     &        dx,
     &        idx)

c         Use Local Lax-Friedrichs to compute hyperbolic part of RHS
c
c         Note: the formulas for the artificial dissipation coefficients
c               _assume_ that phi is approximately a signed distance
c               function to avoid the need for non-local searches over
c               the grid. For details, refer to "Level Set Methods and
c               Dynamic Implicit Surfaces" by Osher & Fedkiw (2003).

c         TODO: implement
          rhs(i,j) = rhs(i,j) + 2

c         --- Compute contribution to stable dt from hyperbolic part of RHS

          grad_phi_x_max = max(abs(grad_phi_x_plus),
     &                         abs(grad_phi_x_minus))
          grad_phi_y_max = max(abs(grad_phi_y_plus),
     &                         abs(grad_phi_y_minus))

c         Note: dx term included to avoid division by zero
c               in computation of stable_inv_dt_local
          norm_grad_phi = sqrt( grad_phi_x_max**2
     &                        + grad_phi_y_max**2
     &                        + max(dx(1), dx(2))**2 )

          stable_inv_dt_local =
     &        abs( V_x_contact_angle
     &           + pressure * grad_phi_x_max / norm_grad_phi )
     &        / dx(1)
     &      + abs( V_y_contact_angle
     &           + pressure * grad_phi_y_max / norm_grad_phi )
     &        / dx(2)

c         --- Compute parabolic part of normal velocity terms of RHS

c         Compute mean curvature
          mean_curvature =
     &        pqsMath2dMeanCurvature(phi, phi_gb_lo, phi_gb_hi,
     &                               dx, idx)

          grad_phi_x_centered = 0.5 * (phi(i+1,j) - phi(i-1,j)) / dx(1)
          grad_phi_y_centered = 0.5 * (phi(i,j+1) - phi(i,j-1)) / dx(2)
          norm_grad_phi = sqrt( grad_phi_x_centered**2
     &                        + grad_phi_y_centered**2 )

c         Compute contribution to RHS
          rhs(i,j) = rhs(i,j)
     &             + surface_tension * mean_curvature * norm_grad_phi

c         Compute contribution to stable dt from parabolic part of RHS
          stable_inv_dt_local = stable_inv_dt_local
     &                        + 2 * surface_tension / dx(1)**2
     &                        + 2 * surface_tension / dx(2)**2

c         --- Update maximum stable dt

          stable_dt_local = 1.0d0 / stable_inv_dt_local
          if (max_stable_dt .gt. stable_dt_local) then
            max_stable_dt = stable_dt_local
          endif

        enddo
      enddo

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute RHS and maximum stable time step (on box) for Slightly
c Compressible Model with zero contact angle.
c
c Parameters
c ----------
c max_stable_dt: [output] maximum stable time step for explicit time
c     integration schemes
c
c rhs: [output] right-hand side of level set evolution equation for
c     Slightly Compressible Model
c
c phi: level set function that defines fluid-fluid interface
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c dx: array containing grid spacing in each coordinate direction
c
c pressure: reference pressure of non-wetting phase
c
c volume: volume of non-wetting phase
c
c target_volume: target volume for non-wetting phase
c
c bulk_modulus: bulk modulus of non-wetting phase
c
c surface_tension: surface tension of interface between wetting
c     and non-wetting phases
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqs2dCompressibleModelZeroContactAngleRHS(
     &  max_stable_dt,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  pressure,
     &  volume,
     &  target_volume,
     &  bulk_modulus,
     &  surface_tension)
c***********************************************************************
c { begin subroutine
      implicit none

      real*8 max_stable_dt

      integer rhs_gb_lo(1:2), rhs_gb_hi(1:2)
      @REAL@  rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &            rhs_gb_lo(2):rhs_gb_hi(2))

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@  phi(phi_gb_lo(1):phi_gb_hi(1),
     &            phi_gb_lo(2):phi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)
      real*8 dx(1:2)

      real*8 pressure
      real*8 volume
      real*8 target_volume
      real*8 bulk_modulus
      real*8 surface_tension

      integer i, j
      integer idx(1:2)

      @REAL@ V_n_pressure
      @REAL@ mean_curvature, pqsMath2dMeanCurvature

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_x_centered, grad_phi_y_centered
      @REAL@ grad_phi_x_max, grad_phi_y_max
      @REAL@ norm_grad_phi

      real*8 stable_dt_local, stable_inv_dt_local

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

c     --- Preparations

      max_stable_dt = 1.0d37

c     Compute pressure-driven component of normal velocity
      V_n_pressure = pressure *
     &    exp(bulk_modulus * (1 - volume/target_volume))

c     --- Compute RHS on patch

      do j=patch_box_lo(2), patch_box_hi(2)
        do i=patch_box_lo(1), patch_box_hi(1)

c         --- Initialize rhs value

          rhs(i,j) = 0.0d0

c         --- Compute hyperbolic part of RHS

c         Compute forward and backward approximations of grad(phi)
          idx(1) = i
          idx(2) = j
          call pqsMath2dComputeGradENO1(
     &        grad_phi_x_plus, grad_phi_x_minus,
     &        grad_phi_y_plus, grad_phi_y_minus,
     &        phi,
     &        phi_gb_lo, phi_gb_hi,
     &        dx,
     &        idx)

c         Use Godunov's method to compute hyperbolic part of RHS
          if (abs(V_n_pressure) .gt. zero_tol) then
            if (V_n_pressure .gt. 0.d0) then
              norm_grad_phi = sqrt(
     &            max(max(grad_phi_x_minus,0.d0)**2,
     &                min(grad_phi_x_plus,0.d0)**2)
     &          + max(max(grad_phi_y_minus,0.d0)**2,
     &                min(grad_phi_y_plus,0.d0)**2))
            else
               norm_grad_phi = sqrt(
     &             max(min(grad_phi_x_minus,0.d0)**2,
     &                 max(grad_phi_x_plus,0.d0)**2)
     &           + max(min(grad_phi_y_minus,0.d0)**2,
     &                 max(grad_phi_y_plus,0.d0)**2))
            endif

            rhs(i,j) = rhs(i,j) - V_n_pressure * norm_grad_phi

          endif

c         --- Compute contribution to stable dt from hyperbolic part of RHS

          grad_phi_x_max = max(abs(grad_phi_x_plus),
     &                         abs(grad_phi_x_minus))
          grad_phi_y_max = max(abs(grad_phi_y_plus),
     &                         abs(grad_phi_y_minus))

c         Note: dx term included to avoid division by zero
c               in computation of stable_inv_dt_local
          norm_grad_phi = sqrt( grad_phi_x_max**2
     &                        + grad_phi_y_max**2
     &                        + max(dx(1), dx(2))**2 )

          stable_inv_dt_local =
     &        abs(V_n_pressure * grad_phi_x_max / norm_grad_phi) / dx(1)
     &      + abs(V_n_pressure * grad_phi_y_max / norm_grad_phi) / dx(2)

c         --- Compute parabolic part of normal velocity terms of RHS

c         Compute mean curvature
          mean_curvature =
     &        pqsMath2dMeanCurvature(phi, phi_gb_lo, phi_gb_hi,
     &                               dx, idx)

          grad_phi_x_centered = 0.5 * (phi(i+1,j) - phi(i-1,j)) / dx(1)
          grad_phi_y_centered = 0.5 * (phi(i,j+1) - phi(i,j-1)) / dx(2)
          norm_grad_phi = sqrt( grad_phi_x_centered**2
     &                        + grad_phi_y_centered**2 )

c         Compute contribution to RHS
          rhs(i,j) = rhs(i,j)
     &             + surface_tension * mean_curvature * norm_grad_phi

c         Compute contribution to stable dt from parabolic part of RHS
          stable_inv_dt_local = stable_inv_dt_local
     &                        + 2 * surface_tension / dx(1)**2
     &                        + 2 * surface_tension / dx(2)**2

c         --- Update maximum stable dt

          stable_dt_local = 1.0d0 / stable_inv_dt_local
          if (max_stable_dt .gt. stable_dt_local) then
            max_stable_dt = stable_dt_local
          endif

        enddo
      enddo

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Compute RHS and maximum stable time step (on box) for Slightly
c Compressible Model with nonzero contact angle.
c
c Parameters
c ----------
c max_stable_dt: [output] maximum stable time step for explicit time
c     integration schemes
c
c rhs: [output] right-hand side of level set evolution equation for
c     Slightly Compressible Model
c
c phi: level set function that defines fluid-fluid interface
c
c psi: level set function that defines solid-pore interface
c
c grad_psi: gradient of level set function that defines solid-pore
c     interface
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c dx: array containing grid spacing in each coordinate direction
c
c pressure: reference pressure of non-wetting phase
c
c volume: volume of non-wetting phase
c
c target_volume: target volume for non-wetting phase
c
c bulk_modulus: bulk modulus of non-wetting phase
c
c surface_tension: surface tension of interface between wetting
c     and non-wetting phases
c
c contact_angle: contact angle between solid-pore interface and
c     the fluid-fluid interface
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqs2dCompressibleModelNonzeroContactAngleRHS(
     &  max_stable_dt,
     &  rhs,
     &  rhs_gb_lo, rhs_gb_hi,
     &  phi,
     &  phi_gb_lo, phi_gb_hi,
     &  psi,
     &  psi_gb_lo, psi_gb_hi,
     &  grad_psi_x, grad_psi_y,
     &  grad_psi_gb_lo, grad_psi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  dx,
     &  pressure,
     &  volume,
     &  target_volume,
     &  bulk_modulus,
     &  surface_tension,
     &  contact_angle)
c***********************************************************************
c { begin subroutine
      implicit none

      real*8 max_stable_dt

      integer rhs_gb_lo(1:2), rhs_gb_hi(1:2)
      @REAL@  rhs(rhs_gb_lo(1):rhs_gb_hi(1),
     &            rhs_gb_lo(2):rhs_gb_hi(2))

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@  phi(phi_gb_lo(1):phi_gb_hi(1),
     &            phi_gb_lo(2):phi_gb_hi(2))

      integer psi_gb_lo(1:2), psi_gb_hi(1:2)
      @REAL@  psi(psi_gb_lo(1):psi_gb_hi(1),
     &            psi_gb_lo(2):psi_gb_hi(2))

      integer grad_psi_gb_lo(1:2), grad_psi_gb_hi(1:2)
      @REAL@  grad_psi_x(grad_psi_gb_lo(1):grad_psi_gb_hi(1),
     &                   grad_psi_gb_lo(2):grad_psi_gb_hi(2))
      @REAL@  grad_psi_y(grad_psi_gb_lo(1):grad_psi_gb_hi(1),
     &                   grad_psi_gb_lo(2):grad_psi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)
      real*8 dx(1:2)

      real*8 pressure
      real*8 volume
      real*8 target_volume
      real*8 bulk_modulus
      real*8 surface_tension
      real*8 contact_angle

      integer i, j
      integer idx(1:2)

      @REAL@ V_x_contact_angle
      @REAL@ V_y_contact_angle
      @REAL@ V_n_pressure
      @REAL@ mean_curvature, pqsMath2dMeanCurvature

      @REAL@ grad_phi_x_plus, grad_phi_x_minus
      @REAL@ grad_phi_y_plus, grad_phi_y_minus
      @REAL@ grad_phi_x_centered, grad_phi_y_centered
      @REAL@ grad_phi_x_max, grad_phi_y_max
      @REAL@ norm_grad_phi

      real*8 stable_dt_local, stable_inv_dt_local

      @REAL@ zero_tol
      parameter (zero_tol=@ZERO_TOL@)

c     --- Preparations

      max_stable_dt = 1.0d37

c     Compute pressure-driven component of normal velocity
      V_n_pressure = pressure *
     &    exp(bulk_modulus * (1 - volume/target_volume))

c     --- Compute RHS on patch

      do j=patch_box_lo(2), patch_box_hi(2)
        do i=patch_box_lo(1), patch_box_hi(1)

c         --- Initialize rhs value

          rhs(i,j) = 0.0d0

c         --- Compute hyperbolic part of RHS

c         Compute contact angle component of advective velocity
c         TODO
          V_x_contact_angle = 0.0d0
          V_y_contact_angle = 0.0d0

c         Compute forward and backward approximations of grad(phi)
          idx(1) = i
          idx(2) = j
          call pqsMath2dComputeGradENO1(
     &        grad_phi_x_plus, grad_phi_x_minus,
     &        grad_phi_y_plus, grad_phi_y_minus,
     &        phi,
     &        phi_gb_lo, phi_gb_hi,
     &        dx,
     &        idx)

c         Use Local Lax-Friedrichs to compute hyperbolic part of RHS
c
c         Note: the formulas for the artificial dissipation coefficients
c               _assume_ that phi is approximately a signed distance
c               function to avoid the need for non-local searches over
c               the grid. For details, refer to "Level Set Methods and
c               Dynamic Implicit Surfaces" by Osher & Fedkiw (2003).

c         TODO: implement
          rhs(i,j) = rhs(i,j) + 2

c         --- Compute contribution to stable dt from hyperbolic part of RHS

          grad_phi_x_max = max(abs(grad_phi_x_plus),
     &                         abs(grad_phi_x_minus))
          grad_phi_y_max = max(abs(grad_phi_y_plus),
     &                         abs(grad_phi_y_minus))

c         Note: dx term included to avoid division by zero
c               in computation of stable_inv_dt_local
          norm_grad_phi = sqrt( grad_phi_x_max**2
     &                        + grad_phi_y_max**2
     &                        + max(dx(1), dx(2))**2 )

          stable_inv_dt_local =
     &        abs( V_x_contact_angle
     &           + V_n_pressure * grad_phi_x_max / norm_grad_phi )
     &        / dx(1)
     &      + abs( V_y_contact_angle
     &           + V_n_pressure * grad_phi_y_max / norm_grad_phi )
     &        / dx(2)

c         --- Compute parabolic part of normal velocity terms of RHS

c         Compute mean curvature
          mean_curvature =
     &        pqsMath2dMeanCurvature(phi, phi_gb_lo, phi_gb_hi,
     &                               dx, idx)

          grad_phi_x_centered = 0.5 * (phi(i+1,j) - phi(i-1,j)) / dx(1)
          grad_phi_y_centered = 0.5 * (phi(i,j+1) - phi(i,j-1)) / dx(2)
          norm_grad_phi = sqrt( grad_phi_x_centered**2
     &                        + grad_phi_y_centered**2 )

c         Compute contribution to RHS
          rhs(i,j) = rhs(i,j)
     &             + surface_tension * mean_curvature * norm_grad_phi

c         Compute contribution to stable dt from parabolic part of RHS
          stable_inv_dt_local = stable_inv_dt_local
     &                        + 2 * surface_tension / dx(1)**2
     &                        + 2 * surface_tension / dx(2)**2

c         --- Update maximum stable dt

          stable_dt_local = 1.0d0 / stable_inv_dt_local
          if (max_stable_dt .gt. stable_dt_local) then
            max_stable_dt = stable_dt_local
          endif

        enddo
      enddo

      return
      end
c } end subroutine
c***********************************************************************

c***********************************************************************
c
c Tag cells for refinement.
c
c Parameters
c ----------
c tag: [output] grid function indicating whether or not cell should
c     be refined
c
c phi: level set function that defines fluid-fluid interface
c
c psi: level set function that defines pore-solid interface
c
c patch_box_lo: lower corner of index range for patch box
c
c patch_box_hi: upper corner of index range for patch box
c
c refinement_cutoff: cutoff value to use to determine whether or
c      not to tag cells for refinement
c
c *_gb_lo: lower corner of index range for ghost box
c
c *_gb_hi: upper corner of index range for ghost box
c
c***********************************************************************
      subroutine pqs2dTagCellsForRefinement(
     &  tag,
     &  tag_gb_lo, tag_gb_hi,
     &  phi, phi_gb_lo, phi_gb_hi,
     &  psi, psi_gb_lo, psi_gb_hi,
     &  patch_box_lo, patch_box_hi,
     &  refinement_cutoff)
c***********************************************************************
c { begin subroutine
      implicit none

      integer tag_gb_lo(1:2), tag_gb_hi(1:2)
      integer tag(tag_gb_lo(1):tag_gb_hi(1),
     &            tag_gb_lo(2):tag_gb_hi(2))

      integer phi_gb_lo(1:2), phi_gb_hi(1:2)
      @REAL@  phi(phi_gb_lo(1):phi_gb_hi(1),
     &            phi_gb_lo(2):phi_gb_hi(2))

      integer psi_gb_lo(1:2), psi_gb_hi(1:2)
      @REAL@  psi(psi_gb_lo(1):psi_gb_hi(1),
     &            psi_gb_lo(2):psi_gb_hi(2))

      integer patch_box_lo(1:2), patch_box_hi(1:2)

      real*8 refinement_cutoff

      integer i, j
      integer idx(1:2)

c     --- Tag cells for refinement

      do j=patch_box_lo(2), patch_box_hi(2)
        do i=patch_box_lo(1), patch_box_hi(1)

          if (abs(phi(i,j)) .lt. refinement_cutoff) then
            tag(i,j) = 1
          else if (abs(psi(i,j)) .lt. refinement_cutoff) then
            tag(i,j) = 1
          else
            tag(i,j) = 0
          endif

        enddo
      enddo

      return
      end
c } end subroutine
c***********************************************************************
